<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Transformation &#8212; The Text Processing Cookbook 0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="_static/basic.css?v=c058f7c8" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=27fed22d" />
    <script src="_static/documentation_options.js?v=2709fde1"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Grouping Data" href="grouping-data.html" />
    <link rel="prev" title="Extraction" href="extraction.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
  
    <link rel="canonical" href="https://thejud.github.io/text-processing-cookbook/transformation.html" />
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="extraction.html" title="Previous document">Extraction</a>
        </li>
        <li>
          <a href="grouping-data.html" title="Next document">Grouping Data</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <section id="transformation">
<h1>Transformation<a class="headerlink" href="#transformation" title="Link to this heading">¶</a></h1>
<p>perl is my tool of choice for many line-oriented transformations. It’s worth
learning a few tricks, and investing some time with one or more of perl, sed or awk.</p>
<section id="general-transformation-with-perl-pe-and-ne">
<h2>General transformation with perl -pE and -nE<a class="headerlink" href="#general-transformation-with-perl-pe-and-ne" title="Link to this heading">¶</a></h2>
<p>The perl -p option turns on filter mode. Any changes made by the expression
argument (-e or -E) will be applied, and then each line will be printed. Using
regular expressions is a good way to remove parts of the line, or add to it.</p>
<p>If you don’t know anything about regular expressions, this will all seem very
mysterious, but if you do much text (or log) munging, it’s worthwhile to learn
the basics.</p>
<p>Here’s an example of removing the date prefix of a timestamp from a log file,
which I have done when I want to compare activity at various times across several days.
My expression is a substitution: s/XXX/YYY/ and I’m replacing everything up to the first T
with the empty string:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>printf &quot;2017-11-01T12:14:22.12352 ERROR critical&quot; \
| perl -pe&#39;s/^.*?T//&#39;  
 12:14:22.12352 ERROR critical
</pre></div>
</div>
<p>You can also extract portions of the line by matching against the entire line.
Here’s a moderately complicated regular expression that extracts the
hour:minute pair, and the log level (ERROR or FATAL). This might be the first
step in analyzing errors per minute.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>printf &quot;2017-11-01T12:14:22.12352 ERROR critical&quot; \
| perl -pe&#39;s/^.*?T(\d\d:\d\d):\S+ (ERROR|FATAL) .*$/$1 $2/&#39;
 12:14 ERROR
</pre></div>
</div>
<p>I tend to prefer to only take the parts I want, rather than replacing the
entire line. perl’s <code class="docutils literal notranslate"><span class="pre">-n</span></code> flag loops over all the input, but doesn’t print
anything. The -E flag is an updated version of the -e flag that just makes some
of the more modern perl features available. I use <code class="docutils literal notranslate"><span class="pre">-E</span></code> mostly so that I can use
<code class="docutils literal notranslate"><span class="pre">say</span> <span class="pre">$var</span></code> instead of <code class="docutils literal notranslate"><span class="pre">print</span> <span class="pre">&quot;$var\n&quot;</span></code>, because say is shorter and automatically
adds a trailing newline.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>printf &quot;2017-11-01T12:14:22.12352 ERROR critical&quot; \
| perl -nE&#39;/T(\d\d:\d\d):\S+ (ERROR|FATAL)/ and say &quot;$1 $2&quot;&#39;
 12:14 ERROR
</pre></div>
</div>
</section>
<section id="create-several-simple-filters-rather-than-one-complicated-one">
<h2>Create several simple filters rather than one complicated one<a class="headerlink" href="#create-several-simple-filters-rather-than-one-complicated-one" title="Link to this heading">¶</a></h2>
<p>Like any other part of your pipeline, it’s fine to clean up your
output progressively with multiple smaller, simpler filters. I often do this
because it’s easier to apply fixes than to get one large regex just right.
Naturally, if you’re building a high-volume or production pipeline, it’s
probably worthwhile to take the time to get it right in fewer steps.</p>
<p>Here’s the filter from the previous recipe broken down into several steps.</p>
<p>Note that in this example I’m using <code class="docutils literal notranslate"><span class="pre">tee</span> <span class="pre">/dev/stderr</span></code> to give some diagnostic
output at each stage in the pipeline so you can see how the line is
progressively refined. You would only want to do that for debugging or
development. The output appears at the end, and I’ve added some blank lines <code class="docutils literal notranslate"><span class="pre">\</span></code>
just to visually separate the steps.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>printf &quot;2017-11-01T12:14:22.12352 ERROR critical&quot; \
| cut -d &#39; &#39; -f 1,2 \
| tee /dev/stderr \
\
| perl -pe&#39;s/^.*?T//&#39; \
| tee /dev/stderr \
\
| perl -pe&#39;s/\.\S+//&#39; \
| tee /dev/stderr \
\
| perl -pe&#39;s/:\d\d / /&#39;
 2017-11-01T12:14:22.12352 ERROR
 12:14:22.12352 ERROR
 12:14:22 ERROR
 12:14 ERROR
</pre></div>
</div>
<p>Another advantage of several simple filters is that you don’t have to spend
time looking up the particular syntax for a more complicated regular expression.</p>
<p>Recently, I’ve been dealing with billions of records in blocks of 10 million or
so. In the logfiles for these tools, I use numbers with comma separation so
it’s a little easier to quickly see the exact magnitude of the numbers. However,
the comma format isn’t as easy for doing math.</p>
<p>Here’s a partial log line. I typically use key=value format in my log as well,
as it is both clear and easy to parse.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>2017-11-20T15:33.16 DEBUG component.func line=9,241,821 per_sec=22,142
</pre></div>
</div>
<p>I wanted to get the average of these per_second values, and so I wrote a little
filter to extract the number:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>head log -1 | perl -nE&#39;/per_sec=(\S+)/ and say $1&#39;
 22,142
</pre></div>
</div>
<p>However that gave me output like “22,124”, which wasn’t yet ready for
averaging. So I spent a minute or two fiddling with the filter and ended up with
the following:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>cat log | perl -nE&#39;/per_sec=(\S+)/ and do { ( $a =$1 ) =~ s/,//g; say $a}&#39;
</pre></div>
</div>
<p>Not too bad, and with a bit more golfing I could have gotten it down to
something shorter. However, splitting this procedure up into two separate
transformations would have made it much easier:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>head -1 log | perl -nE&#39;/per_sec=(\S+)/ and say $1&#39; | tr -d &#39;,&#39;
 22142
</pre></div>
</div>
<p>The advantage of this approach is that I don’t have to remember some special
perl syntax. I spent too much time messing around, trying to get it right when
it would have been simpler to refine it in two minimal filters that I could
write correctly the first time (or with 5 seconds looking at the tr manpage
after <code class="docutils literal notranslate"><span class="pre">tr</span> <span class="pre">','</span> <span class="pre">&quot;&quot;</span></code> didn’t work.</p>
<p>To conclude this recipe, to compute the average, I just piped the resulting
values into the <code class="docutils literal notranslate"><span class="pre">stats</span></code> script, referenced below. Again, I could have written
some more perl to aggregate values and then print the results at eof or in an
END block, but I’d have spent a bit more time fiddling (or googling), and I
really just had a simple 60 second question to see if the average was above
or below the last few values I saw in the logfile.</p>
</section>
<section id="collapse-or-replace-spaces-and-newlines">
<h2>collapse or replace spaces and newlines<a class="headerlink" href="#collapse-or-replace-spaces-and-newlines" title="Link to this heading">¶</a></h2>
<p>perl has a few character classes in regular expressions that are worthwhile:</p>
<ul class="simple">
<li><p>\s is for general whitespace (spaces, newlines and tabs)</p></li>
<li><p>\h is for horizontal whitespace (spaces and tabs, NOT newlines)</p></li>
<li><p>\v is for vertical whitespace (newlines)</p></li>
<li><p>\t is for tabs</p></li>
</ul>
<p>So, to collapse multiple spaces or tabs into a single character (“:” in this case):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>printf &quot;a b c\nfoo bar baz\n&quot; | column -t | tee data
 a    b    c
 foo  bar  baz
</pre></div>
</div>
<p>To collapse the (horizontal) spaces and tabs:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>perl -pE&#39;s/\h+/:/g&#39; data
 a:b:c
 foo:bar:baz
</pre></div>
</div>
<p>To collapse the vertical newlines:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>perl -pE&#39;s/\v+/:/g&#39; data   # or \n
 a    b    c:foo  bar  baz:
</pre></div>
</div>
<p>To collapse both spaces and newlines:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>perl -pE&#39;s/\s+/:/g&#39; data
 a:b:c:foo:bar:baz:
</pre></div>
</div>
</section>
<section id="convert-spaces-to-newline-with-tr-or-perl">
<h2>convert spaces to newline with tr or perl<a class="headerlink" href="#convert-spaces-to-newline-with-tr-or-perl" title="Link to this heading">¶</a></h2>
<p>tr is a simple solution here, as long as you only want one to one replacement:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>echo &quot;1 2 3&quot; | tr &quot; &quot; &#39;\n&#39;
 1
 2
 3
</pre></div>
</div>
<p>Collapse multiple spaces with the squeeze (-s) option:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>echo &quot;1   2 3&quot; | tr -s &quot; &quot; &#39;\n&#39;
 1
 2
 3
</pre></div>
</div>
<p>As described in the perl section above, you can use perl to replace spaces with newlines:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>echo &quot;1   2 3&quot; | perl -pe&#39;s/ +/\n/g&#39; 
 1
 2
 3
</pre></div>
</div>
<p>Or via autosplit + join:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>echo &quot;1   2 3&quot; | perl -anE&#39;say join &quot;\n&quot;, @F&#39;
</pre></div>
</div>
</section>
<section id="remove-newlines-with-perl">
<h2>remove newlines with perl<a class="headerlink" href="#remove-newlines-with-perl" title="Link to this heading">¶</a></h2>
<p>Replace newlines, or vertical whitespace (a bit more cross-platform):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>seq 10 | perl -pe&#39;s/\v/ /g&#39; 
 1 2 3 4 5 6 7 8 9 10 
</pre></div>
</div>
<p>Keep the final newline:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>seq 10 | perl -pe&#39;s/\v/ / unless eof&#39;
 1 2 3 4 5 6 7 8 9 10
</pre></div>
</div>
</section>
<section id="reshape-text-with-rs">
<h2>reshape text with rs<a class="headerlink" href="#reshape-text-with-rs" title="Link to this heading">¶</a></h2>
<p>A little tool I discovered recently is <code class="docutils literal notranslate"><span class="pre">rs</span></code> :</p>
<ul>
<li><p>http://manpages.ubuntu.com/manpages/xenial/man1/rs.1.html</p></li>
<li><p>https://github.com/chneukirchen/rs</p></li>
<li><p>appears built-in on mac</p>
<p>seq 12 | rs 3 4
1   2   3   4
5   6   7   8
9   10  11  12</p>
</li>
</ul>
<p>or to transpose row and column order with <code class="docutils literal notranslate"><span class="pre">-t</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>seq 11 | rs -t 3 4
 1   4   7   10
 2   5   8   11
 3   6   9
</pre></div>
</div>
<p>Or to collapse. Use 0 to automatically determine the other value:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>seq 6 | rs 1 0
 1  2  3  4  5  6
</pre></div>
</div>
<p>And just to show it is smart about collapsing arrays:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>seq 6 | rs 2 3 | rs 1 0
 1  2  3  4  5  6

seq 6 | rs 2 3 | rs 0 5
 1  2  3  4  5
 6  
</pre></div>
</div>
<p>I’m just playing with <code class="docutils literal notranslate"><span class="pre">rs</span></code> a bit, there are a lot more options, and it doesn’t
appear to be widely available. However, it’s nice if you want to specify the
columns and rows.</p>
</section>
<section id="merge-sort-multiple-files-of-sorted-data">
<h2>merge sort  multiple files of sorted data<a class="headerlink" href="#merge-sort-multiple-files-of-sorted-data" title="Link to this heading">¶</a></h2>
<p>Sometimes I have data that has already been sorted by another process. GNU sort
is very powerful and has a variety of features like parallel sorting and large
file sorting (more on sort below). It also provides merge sorting of pre-sorted
files via the <code class="docutils literal notranslate"><span class="pre">--merge</span></code> switch.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>sort --merge sorted1 sorted2 sorted3
</pre></div>
</div>
</section>
<section id="paste-add-files-side-by-side">
<h2>paste: add files side by side<a class="headerlink" href="#paste-add-files-side-by-side" title="Link to this heading">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">seq</span> <span class="mi">1</span> <span class="mi">5</span> <span class="o">&gt;</span> <span class="n">a</span>
<span class="n">seq</span> <span class="o">-</span><span class="n">w</span> <span class="mi">0</span> <span class="mf">.5</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="n">b</span>
<span class="n">seq</span> <span class="mi">6</span> <span class="mi">10</span> <span class="o">&gt;</span> <span class="n">c</span>

<span class="n">paste</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span>
 <span class="mi">1</span>    <span class="mf">0.0</span>    <span class="mi">6</span>
 <span class="mi">2</span>    <span class="mf">0.5</span>    <span class="mi">7</span>
 <span class="mi">3</span>    <span class="mf">1.0</span>    <span class="mi">8</span>
 <span class="mi">4</span>    <span class="mf">1.5</span>    <span class="mi">9</span>
 <span class="mi">5</span>    <span class="mf">2.0</span>    <span class="mi">10</span>
</pre></div>
</div>
<p>Note that you can also use paste to transform a single stream into multiple
columns by including the desired number of stdin reads, <code class="docutils literal notranslate"><span class="pre">paste</span> <span class="pre">-</span> <span class="pre">-</span></code> or
<code class="docutils literal notranslate"><span class="pre">paste</span> <span class="pre">-</span> <span class="pre">-</span> <span class="pre">-</span> <span class="pre">-</span> <span class="pre">-</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>seq 10 | paste - - -
 1	2	3
 4	5	6
 7	8	9
 10		
</pre></div>
</div>
</section>
<section id="join-intersect-two-files">
<h2>join: intersect two files<a class="headerlink" href="#join-intersect-two-files" title="Link to this heading">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">join</span></code> is use to match rows or items in one file with another.</p>
<p>It can be used, much like a database, to join rows that match other
rows based on a field from each file. It requires each file to be
sorted on the join field, however.</p>
<p>Other than basic lookup, I also use join to fill in missing values in a
sequence. For example, I have a file with per-minute error counts, and I want
to see both the minutes with errors, and the minutes without errors (which are
not present in the input). The errors data could be the output of a frequency
count pipeline, described below.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>cat &gt; errors &lt;&lt;EOM
12	12:31
12	12:34
19	12:32
23	12:36
99	12:37
EOM
</pre></div>
</div>
<p>And we’ll generate all the minutes in our range. See the generation section or
the section on gnu parallel for some additional ideas, but here’s an example of
using the seq command with a template. tee prints the output both to a file, and
to the screen.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>seq -f &quot;12:%02.0f&quot; 31 37 | tee minutes
12:31
12:32
12:33
12:34
12:35
12:36
12:37
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">join</span></code> requires that the both input files are pre-sorted by the join key, and so
we will have to re-sort the errors table before joining. I’ll sort inplace, by
telling sort to output to a file (the input file) when complete. Note that unlike
a normal output redirect, sort is smart enough to only create/rename the output
file when the sort operation is complete. However, a temp file would work just
as well. I’m sorting on field #2, and sort uses whitespace as column delimiters
by default. We’ll skip the items table, since it’s already sorted.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>sort -o errors -k 2 errors
</pre></div>
</div>
<p>Now we’re ready to do the join. We need to specify what fields we want to join
on from each file. Since we want the first (and only) field from minutes, we can
omit it. <code class="docutils literal notranslate"><span class="pre">-a</span> <span class="pre">2</span></code> tells join to show missing matches from the minutes file,
and <code class="docutils literal notranslate"><span class="pre">-1</span> <span class="pre">2</span></code> tells join to use the join key from file 1, field 2.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>join  -a 2 -1 2 errors minutes
 12:31 12
 12:32 19
 12:33
 12:34 12
 12:35
 12:36 23
 12:37 99
</pre></div>
</div>
<p>With an additional filter, we could add a default value of zero, but it is
now clear in context which values are missing.</p>
<p>See also: <code class="docutils literal notranslate"><span class="pre">comm</span></code></p>
</section>
<section id="concatenate-files-skipping-header-line">
<h2>Concatenate files, skipping header line<a class="headerlink" href="#concatenate-files-skipping-header-line" title="Link to this heading">¶</a></h2>
<p>Often I want to combine multiple files that already have headers, most commonly
with CSV data. However, sometime I have data with a comment block at the top.</p>
<p>the <code class="docutils literal notranslate"><span class="pre">csvstack</span></code> command (<code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">csvkit</span></code>) is ideal if the data is csv.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>csvstack f1.csv f2.csv f3.csv
</pre></div>
</div>
<p>Here’s a simple script to join files with headers:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#!/usr/bin/env python
&quot;&quot;&quot;join files with a header line&quot;&quot;&quot;

from __future__ import print_function
import fileinput

for line in fileinput.input():
  if not fileinput.isfirstline() or fileinput.lineno() == 1:
    print(line, end=&quot;&quot;)
</pre></div>
</div>
</section>
<section id="remove-the-first-n-lines-of-a-file-with-tail">
<h2>Remove the first n lines of a file with tail<a class="headerlink" href="#remove-the-first-n-lines-of-a-file-with-tail" title="Link to this heading">¶</a></h2>
<p>Tail is typically used to display the last n lines of a file, e.g. get the final (largest) 5 values with <code class="docutils literal notranslate"><span class="pre">sort</span> <span class="pre">data</span> <span class="pre">|</span> <span class="pre">tail</span> <span class="pre">-5</span></code></p>
<p>However, it can also skip lines if you provide a positive offset, e.g.
<code class="docutils literal notranslate"><span class="pre">tail</span> <span class="pre">+10</span></code> or <code class="docutils literal notranslate"><span class="pre">tail</span> <span class="pre">-n</span> <span class="pre">+10</span></code> The catch is that the number you provide is where
it will start printing, <em>one less</em> than the number of lines will be skipped.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># starts on line 3
seq 5 | tail +3 
3
4
5
</pre></div>
</div>
<p>Note: If you actually want the top 5 values from a dataset, it’s more common to
reverse the sort and take the first values, e.g. <code class="docutils literal notranslate"><span class="pre">sort</span> <span class="pre">-nr</span> <span class="pre">data</span> <span class="pre">|</span> <span class="pre">head</span> <span class="pre">-5</span></code>
which should be just as fast to sort, and avoids reading through the entire
file just to get the last few values, which is what tail must do when reading
from a pipe.</p>
</section>
<section id="sort-a-file-with-a-header">
<h2>Sort a file with a header<a class="headerlink" href="#sort-a-file-with-a-header" title="Link to this heading">¶</a></h2>
<p>Sometimes you have a file that has a multiline header, and you’d like to sort
the data but keep the header. One nice technique is to print the header to
stderr, and then process the rest of the file before displaying it. This is
also a nice way to provide users with a variety of options to sort the
output, assuming it is in easily sortable form.</p>
<p>It’s pretty easy to do this with head and tail, although you have to remember
that the offsets are off by one:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>cat &gt; data &lt;EOM
 # Here&#39;s some data
 # with a header
 20
 5
 1
 15
 EOM
</pre></div>
</div>
<p>Now, I’d like to sort the data in descending order, but the header gets sorted
as well.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>sort -nr data
 20
 13
 5
 1
 # with a header
 # Here&#39;s some data
</pre></div>
</div>
<p>Instead, if we put the header on stderr, and then sort the rest, we’ll get what we want
printed to the terminal.</p>
<p><strong>NOTE</strong> This will NOT put the header into the output pipeline. See the bottom of this
recipe for an alternative.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>head -2 data &gt; /dev/stderr; tail +3 data  | sort -nr
 # Here&#39;s some data
 # with a header
 20
 13
 5
 1
</pre></div>
</div>
<p>Now, with this small behead script, we can sort only the data portion
of a file:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#!/usr/bin/env perl
use Getopt::Std;
my $opt_n = 1;
getopts(&#39;n:&#39;);

while(&lt;&gt;) {
  if ($. &lt;= $opt_n ) {
    print STDERR;
  } else { 
    print
  }
}

behead -2 data | sort -nr
 # Here&#39;s some data
 # with a header
 20
 15
 5
 1
</pre></div>
</div>
<p>Another interesting use of behead is to quickly see both the first and last value of some input,
like a range query.</p>
<p>IMPORTANT NOTE: behead prints output to stderr, so this isn’t suitable for piping to another
command, but can be useful just to see in the terminal.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>seq -w 1 10 | behead | tail -1
 01
 10
</pre></div>
</div>
<p>If you want to capture both the header and the sorted body, use the command-block/subshell technique:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>( head -2 data; tail +3 data | sort -nr ) &gt; data.sorted
</pre></div>
</div>
</section>
<section id="put-data-into-a-specific-number-of-columns-with-pr">
<h2>put data into a specific number of columns with pr<a class="headerlink" href="#put-data-into-a-specific-number-of-columns-with-pr" title="Link to this heading">¶</a></h2>
<p>The pr command is used to format text files for printing, and it has a large
set of options. It can also be used to do some useful things for display.
Unlike <code class="docutils literal notranslate"><span class="pre">rs</span></code>, it is standard on nearly every linux system.</p>
<p>Note that the -t option is required to skip the unwanted page header that is
intended for print output.</p>
<p>Three columns. Fill down columns first.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">seq</span> <span class="mi">10</span> <span class="o">|</span> <span class="n">pr</span> <span class="o">-</span><span class="n">t</span> <span class="o">-</span><span class="mi">3</span>
<span class="mi">1</span>            <span class="mi">5</span>            <span class="mi">9</span>
<span class="mi">2</span>            <span class="mi">6</span>            <span class="mi">10</span>
<span class="mi">3</span>            <span class="mi">7</span>
<span class="mi">4</span>            <span class="mi">8</span>
</pre></div>
</div>
<p>Three columns. Fill across rows first.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">seq</span> <span class="mi">10</span> <span class="o">|</span> <span class="n">pr</span> <span class="o">-</span><span class="n">t</span> <span class="o">-</span><span class="mi">3</span> <span class="o">-</span><span class="n">a</span>
<span class="mi">1</span>            <span class="mi">2</span>            <span class="mi">3</span>
<span class="mi">4</span>            <span class="mi">5</span>            <span class="mi">6</span>
<span class="mi">7</span>            <span class="mi">8</span>            <span class="mi">9</span>
<span class="mi">10</span>
</pre></div>
</div>
</section>
<section id="making-data-tables-with-column">
<h2>making data tables with column<a class="headerlink" href="#making-data-tables-with-column" title="Link to this heading">¶</a></h2>
<p>Sometime you have unevenly spaced fields (or words), and you’d like to turn it
into nice white-space separated columns. The column command has a table mode
for just this. I often use this to either pretty print a command’s fields, or
for pretty printing parts of a log file (note that it’s not good for the entire
line, as it works best when there are a limited (and constant) number of
columns.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>cat &gt; mytxt &lt;&lt;EOF
the quick brown fox
jumped over the lazy
dogs and it was
so very, very funny
EOF
</pre></div>
</div>
<p>Use the table mode <code class="docutils literal notranslate"><span class="pre">-t</span></code> to turn it into variable width columns, each sized
according to the largest item.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>column -t mytxt
 the     quick  brown  fox
 jumped  over   the    lazy
 dogs    and    it     was
 so      very,  very   funny
</pre></div>
</div>
</section>
<section id="use-column-to-create-a-flexible-number-of-columns-to-fill-the-width">
<h2>Use column to create a flexible number of columns to fill the width.<a class="headerlink" href="#use-column-to-create-a-flexible-number-of-columns-to-fill-the-width" title="Link to this heading">¶</a></h2>
<p>pr is useful when you know how many columns you want to create. <code class="docutils literal notranslate"><span class="pre">column</span></code> also
has a mode to create columns, but unlike pr, you set the width you want, and
column will create an appropriate number of columns to fill it.</p>
<p>Fill down columns first.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">seq</span> <span class="mi">30</span> <span class="o">|</span> <span class="n">column</span> <span class="o">-</span><span class="n">c</span> <span class="mi">40</span>
<span class="mi">1</span>       <span class="mi">7</span>       <span class="mi">13</span>      <span class="mi">19</span>      <span class="mi">25</span>
<span class="mi">2</span>       <span class="mi">8</span>       <span class="mi">14</span>      <span class="mi">20</span>      <span class="mi">26</span>
<span class="mi">3</span>       <span class="mi">9</span>       <span class="mi">15</span>      <span class="mi">21</span>      <span class="mi">27</span>
<span class="mi">4</span>       <span class="mi">10</span>      <span class="mi">16</span>      <span class="mi">22</span>      <span class="mi">28</span>
<span class="mi">5</span>       <span class="mi">11</span>      <span class="mi">17</span>      <span class="mi">23</span>      <span class="mi">29</span>
<span class="mi">6</span>       <span class="mi">12</span>      <span class="mi">18</span>      <span class="mi">24</span>      <span class="mi">30</span>
</pre></div>
</div>
<p>Same as above, but fill across first.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">seq</span> <span class="mi">30</span> <span class="o">|</span> <span class="n">column</span> <span class="o">-</span><span class="n">c</span> <span class="mi">40</span> <span class="o">-</span><span class="n">x</span>
<span class="mi">1</span>       <span class="mi">2</span>       <span class="mi">3</span>       <span class="mi">4</span>       <span class="mi">5</span>
<span class="mi">6</span>       <span class="mi">7</span>       <span class="mi">8</span>       <span class="mi">9</span>       <span class="mi">10</span>
<span class="mi">11</span>      <span class="mi">12</span>      <span class="mi">13</span>      <span class="mi">14</span>      <span class="mi">15</span>
<span class="mi">16</span>      <span class="mi">17</span>      <span class="mi">18</span>      <span class="mi">19</span>      <span class="mi">20</span>
<span class="mi">21</span>      <span class="mi">22</span>      <span class="mi">23</span>      <span class="mi">24</span>      <span class="mi">25</span>
<span class="mi">26</span>      <span class="mi">27</span>      <span class="mi">28</span>      <span class="mi">29</span>      <span class="mi">30</span>
</pre></div>
</div>
</section>
<section id="joining-all-lines-with-xargs-or-paste">
<h2>joining all lines with xargs or paste<a class="headerlink" href="#joining-all-lines-with-xargs-or-paste" title="Link to this heading">¶</a></h2>
<p>If you just want all the items on the same line, <code class="docutils literal notranslate"><span class="pre">xargs</span></code> is quick and dirty,
joining with spaces. <code class="docutils literal notranslate"><span class="pre">xargs</span> <span class="pre">echo</span></code> can also be used.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>seq 20 | xargs
 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
</pre></div>
</div>
<p>To have a specific number of columns, still space separated, have xargs break
it up for you. here’s we’re choosing 5 at a time, and notice that the alignment
isn’t very good. See <code class="docutils literal notranslate"><span class="pre">column</span></code> above for how to align columns.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>seq 20 | xargs -n5 echo
 1 2 3 4 5
 6 7 8 9 10
 11 12 13 14 15
 16 17 18 19 20
</pre></div>
</div>
<p>See below for the section on xargs.</p>
<p>paste also provides a way to join all lines, the <code class="docutils literal notranslate"><span class="pre">-s</span></code> option. By default, paste
joins using a tab, but you can change that with the <code class="docutils literal notranslate"><span class="pre">-d</span></code>  option.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>seq 5 | paste -s -
 1       2       3       4       5
</pre></div>
</div>
<p>And to create comma-separated lists, provide a delimiter with the <code class="docutils literal notranslate"><span class="pre">-d</span></code> flag:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>seq 5 | paste -s -d, -
 1,2,3,4,5
</pre></div>
</div>
</section>
<section id="joining-transforming-all-except-the-last-line-with-perl">
<h2>joining/transforming all except the last line with perl<a class="headerlink" href="#joining-transforming-all-except-the-last-line-with-perl" title="Link to this heading">¶</a></h2>
<p>Here’s another way to join a set of lines, but keep the last one intact. Useful if you want to create a comma-separated.</p>
<p>Use a perl transformation like <code class="docutils literal notranslate"><span class="pre">perl</span> <span class="pre">-pe's/\n/:/</span> <span class="pre">unless</span> <span class="pre">eof'</span></code> to join with other characters.</p>
<p>seq 5 | perl -pe’s/\n/:/ unless eof’
1:2:3:4:5</p>
<p>This recipe can be generalized to apply any transformation to all except the last line.</p>
</section>
<section id="transform-one-column-at-a-time">
<h2>Transform one column at a time<a class="headerlink" href="#transform-one-column-at-a-time" title="Link to this heading">¶</a></h2>
<p>Sometimes I want to work on only one column of a multi-column file. A very
common case is transforming the timestamp of some data, or a time-based ID to a
timestamp. Other possible cases include doing some lookup, hashing, and data obfuscation.</p>
<p>If the transformation is quite simple, perl or awk can be used:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>cat &lt;&lt;EOF | tee data
1  2018-04-01  foo
2  2018-04-01  bar
3  2018-04-02  baz
4  2018-04-03  cat
EOF
</pre></div>
</div>
<p>Here’s an example of using two simple awk filters to increment column 1, and
uppercase column 3:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>cat data | awk &#39;$1=$1+7&#39; | awk &#39;$3=toupper($3)&#39;
 8 2018-04-01 FOO
 9 2018-04-01 BAR
 10 2018-04-02 BAZ
 11 2018-04-03 CAT
</pre></div>
</div>
<p>A relatively complicated way to do the same thing with perl’s autosplit:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>perl -anE&#39;$F[0]+= 7; $F[-1] = uc($F[-1]); say join(&quot; &quot;, @F)&#39; data
 8 2018-04-01 FOO
 9 2018-04-01 BAR
 10 2018-04-02 BAZ
 11 2018-04-03 CAT
</pre></div>
</div>
<section id="split-transform-and-recombine-columns">
<h3>Split, transform and recombine columns<a class="headerlink" href="#split-transform-and-recombine-columns" title="Link to this heading">¶</a></h3>
<p>However, sometimes the transformation is more complicated than I’d want to try
inline, or I have an existing tool or filter that will work on a column of
data. One technique is to split the input into separate files by column,
process each column separately, and then recombine the column files with the
<code class="docutils literal notranslate"><span class="pre">paste</span></code> command. Note that this most useful when the number of columns is
relatively small. Here I’m doing it with the same 3-column file.</p>
<p>Create one file per column:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>awk &#39;{print $1}&#39; data &gt; a.01
awk &#39;{print $2}&#39; data &gt; a.02
awk &#39;{print $3}&#39; data &gt; a.03
</pre></div>
</div>
<p>Transform a column. Here we use a tempfile and would overwrite the original
file only if the command succeeds:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>cat a.02 | tr -d &#39;a&#39; &gt; tmp
mv tmp a.02
</pre></div>
</div>
<p>Verify that the files still have the same number of lines:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>wc -l a.0*
   4 a.01
   4 a.02
   4 a.03
  12 total
</pre></div>
</div>
<p>Recombine the columns using paste. Separate with a space to match the input
file format.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>paste -d &quot; &quot; a.01 a.02 a.03
 1 2018-04-01 foo
 2 2018-04-01 br
 3 2018-04-02 bz
 4 2018-04-03 ct
</pre></div>
</div>
<p>Note that there are some problems with this approach. The most significant is
that your transformation script must return a single line of output for every
line of input, or the columns will become misaligned. Also, you end up
re-reading the input file several times, which may be ok with a small number of
columns, or a small file. Naturally, column extraction could be scripted with a
for loop, or a dedicated, smarter tool, but then things begin to get
complicated.</p>
<p>Loop to extract columns 1,2 and 3:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>for i in `seq 3`; do awk &quot;{print \$$i}&quot; data &gt; a.$i ; done
</pre></div>
</div>
<p>Finally, awk and paste are best for simple, whitespace delimited files, but you
could use something like <code class="docutils literal notranslate"><span class="pre">csvcut</span></code> (from <code class="docutils literal notranslate"><span class="pre">csvkit</span></code>, described below) and <code class="docutils literal notranslate"><span class="pre">paste</span> <span class="pre">-d,</span></code> to handle CSV files.</p>
<p>Update:</p>
<p>Here’s a cool solution for many columns via stack overflow
(https://stackoverflow.com/a/41863438). It makes use of the GNU split command
to group every Nth line together into a separate file without multiple passes through the
input. WARNING: The built-in split on OSX <strong>DOESN’T</strong> have the required
functionality, so you’ll need to install the GNU version. e.g. <code class="docutils literal notranslate"><span class="pre">brew</span> <span class="pre">install</span> <span class="pre">coreutils</span></code>. Under that same stack overflow question is a pure-awk solution, but
it’s also a bit complicated.</p>
<p>Create a sample file with 10 columns:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>seq 50 | xargs -n10 | tee data
 1 2 3 4 5 6 7 8 9 10
 11 12 13 14 15 16 17 18 19 20
 21 22 23 24 25 26 27 28 29 30
 31 32 33 34 35 36 37 38 39 40
 41 42 43 44 45 46 47 48 49 50
</pre></div>
</div>
<p>Create one file per column by first collapsing the input rows into one cell per
line. These lines are split into 10 files, with every line going round-robin into
a separate (per-column) file.
Then transform the 9th column, and paste the files back together:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>cat data | tr &#39; &#39; &#39;\n&#39; | gsplit -nr/10 -d - /tmp/transform.
perl -ni -E&#39;say $_*10&#39;  /tmp/transform.08
paste -d &#39; &#39; /tmp/transform.*
 1 2 3 4 5 6 7 8 90 10
 11 12 13 14 15 16 17 18 190 20
 21 22 23 24 25 26 27 28 290 30
 31 32 33 34 35 36 37 38 390 40
 41 42 43 44 45 46 47 48 490 50
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">gsplit</span></code> (or <code class="docutils literal notranslate"><span class="pre">split</span></code> on linux) command magic is as follows:</p>
<ul class="simple">
<li><p>extract every 10th line into its own file, round robin style <code class="docutils literal notranslate"><span class="pre">-nr/10</span></code></p></li>
<li><p>create numeric filename suffixes <code class="docutils literal notranslate"><span class="pre">-d</span></code> (default to 2 digits. Starts with 00)</p></li>
<li><p>read from STDIN <code class="docutils literal notranslate"><span class="pre">-</span></code></p></li>
<li><p>write output files with a prefix <code class="docutils literal notranslate"><span class="pre">/tmp/transform.</span></code></p></li>
</ul>
<p>Note that the split files start at 00, so we transformed the 9th column in
<code class="docutils literal notranslate"><span class="pre">/tmp/transform.08</span></code>. We did another trivial transformation (multiply the value
by 10).</p>
</section>
</section>
</section>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="extraction.html" title="Previous document">Extraction</a>
        </li>
        <li>
          <a href="grouping-data.html" title="Next document">Grouping Data</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/80s_keycaps.png" alt="Logo of The Text Processing Cookbook"/>
            </a></p>
<h1 class="logo"><a href="index.html">The Text Processing Cookbook</a></h1>



<p class="blurb">Tools and techniques for processing text and data on the command line by Jud Dagnall</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=thejud&repo=text-processing-cookbook&type=star&count=True&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>






<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">An Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="filter-and-select.html">Filter and Select</a></li>
<li class="toctree-l1"><a class="reference internal" href="extraction.html">Extraction</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Transformation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#general-transformation-with-perl-pe-and-ne">General transformation with perl -pE and -nE</a></li>
<li class="toctree-l2"><a class="reference internal" href="#create-several-simple-filters-rather-than-one-complicated-one">Create several simple filters rather than one complicated one</a></li>
<li class="toctree-l2"><a class="reference internal" href="#collapse-or-replace-spaces-and-newlines">collapse or replace spaces and newlines</a></li>
<li class="toctree-l2"><a class="reference internal" href="#convert-spaces-to-newline-with-tr-or-perl">convert spaces to newline with tr or perl</a></li>
<li class="toctree-l2"><a class="reference internal" href="#remove-newlines-with-perl">remove newlines with perl</a></li>
<li class="toctree-l2"><a class="reference internal" href="#reshape-text-with-rs">reshape text with rs</a></li>
<li class="toctree-l2"><a class="reference internal" href="#merge-sort-multiple-files-of-sorted-data">merge sort  multiple files of sorted data</a></li>
<li class="toctree-l2"><a class="reference internal" href="#paste-add-files-side-by-side">paste: add files side by side</a></li>
<li class="toctree-l2"><a class="reference internal" href="#join-intersect-two-files">join: intersect two files</a></li>
<li class="toctree-l2"><a class="reference internal" href="#concatenate-files-skipping-header-line">Concatenate files, skipping header line</a></li>
<li class="toctree-l2"><a class="reference internal" href="#remove-the-first-n-lines-of-a-file-with-tail">Remove the first n lines of a file with tail</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sort-a-file-with-a-header">Sort a file with a header</a></li>
<li class="toctree-l2"><a class="reference internal" href="#put-data-into-a-specific-number-of-columns-with-pr">put data into a specific number of columns with pr</a></li>
<li class="toctree-l2"><a class="reference internal" href="#making-data-tables-with-column">making data tables with column</a></li>
<li class="toctree-l2"><a class="reference internal" href="#use-column-to-create-a-flexible-number-of-columns-to-fill-the-width">Use column to create a flexible number of columns to fill the width.</a></li>
<li class="toctree-l2"><a class="reference internal" href="#joining-all-lines-with-xargs-or-paste">joining all lines with xargs or paste</a></li>
<li class="toctree-l2"><a class="reference internal" href="#joining-transforming-all-except-the-last-line-with-perl">joining/transforming all except the last line with perl</a></li>
<li class="toctree-l2"><a class="reference internal" href="#transform-one-column-at-a-time">Transform one column at a time</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="grouping-data.html">Grouping Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="frequency-counts-and-distributions.html">Frequency Counts and Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="specialized-data-tools.html">Specialized Tools for Aggregation, Summary, Analysis and Reporting</a></li>
<li class="toctree-l1"><a class="reference internal" href="csv-tsv-json.html">CSV and TSV</a></li>
<li class="toctree-l1"><a class="reference internal" href="csv-tsv-json.html#json">json</a></li>
<li class="toctree-l1"><a class="reference internal" href="sorting.html">Sorting</a></li>
<li class="toctree-l1"><a class="reference internal" href="generating-data.html">Generating Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="batch-and-parallel-execution.html">Batch and parallel execution with xargs and parallel</a></li>
<li class="toctree-l1"><a class="reference internal" href="visualization.html">Visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="visualization.html#misc">Misc</a></li>
<li class="toctree-l1"><a class="reference internal" href="solutions.html">Solutions: Putting it all together</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="extraction.html" title="previous chapter">Extraction</a></li>
      <li>Next: <a href="grouping-data.html" title="next chapter">Grouping Data</a></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2024, Jud Dagnall.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.0.2</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="_sources/transformation.md.txt"
          rel="nofollow">Page source</a>
    </div>

    
    <a href="https://github.com/thejud/text-processing-cookbook" class="github">
        <img src="_static/github-banner.svg" alt="Fork me on GitHub" class="github"/>
    </a>
    

    
  </body>
</html>